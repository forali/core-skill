## Java并发编程实战

> 参考《Java并发编程实战》
## Concurrent in action

如果多个线程访问同一个可变的状态变量时，需要使用如下策略保持线程安全。

- 不在线程之间共享该状态变量（将变量设置为局部变量）
- 将状态变量设置为不可变（final）
- 访问状态变量使用同步（synchronized、lock）

编写并发程序正确方法：先让代码正确运行、然后让代码运行速度变快。

良好的面向对象技术、不可修改性和明晰的不变性规则有利于设计线程安全的类。

线程安全性中，最核心的概念就是正确性。正确性的含义是，某个类的行为与其规范完全一致。

良好的规范中通常会定义各种不变形条件来约束对象的状态，以及定义各种后验条件描述对象的操作结果。

**复合操作（非线程安全）：**延迟初始化（先检查后执行）；递增操作（读取-修改-写入）

**线程安全性：**当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

在线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步机制。

**无状态的对象**一定是线程安全的。对象中不包含任何域，也不包含对任何其他类域的引用。

**竟态条件：**计算的正确性取决于多个线程的交替执行时序。最常见的竟态条件类型就是“先检查后执行”

当为无状态类添加一个状态时，如果改状态由一个线程安全的对象来管理，那么这个类仍是线程安全的。（如果添加多个状态，则没有添加一个状态那么简单）

当不变性条件涉及多个状态时，更新某个状态，需要在同一个原子操作中对其他变量同时进行更新。

**内置锁或监视器锁：**每个java对象都可以作为实现同步的锁。属于互斥锁、可重入

**重入锁：**为每一个锁关联一个计数器和所有者线程，计数器为0说明该锁没有被任何线程持有。当线程获取一个锁，锁会记录下线程并且计数器加一。如果该线程再次请求该锁，则计数器加一，当线程退出同步块时，计数器减一。

使用锁来协调对某个变量访问（查看和修改）时，在访问变量的所有位置上都需要使用同一个锁。

**锁保护的数据：**并非所有的数据都需要被锁保护，那些共享的可变数据才需要被锁保护。

对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁保护

### 第三章 对象的共享

**非原子的64位操作：**java虚拟机中long和double的读写操作分为两个32位操作，是非原子的。所以共享的可变变量是long或者double是非线程安全的。

**加锁与可见性：**加锁不仅局限于互斥行为，还包括可见性。

#### volatile关键字

**volatile：**使被修饰的对象具有可见性，并且避免编译或运行时重排序。但是不能确保递增操作（count++）是原子性的。

加锁机制既能保证可见性又能保证原子性，二volatile吧变量只能确保可见性。

当且仅当满足下列条件使用volatile:

- 对变量的写入不依赖变量当前的值，或者能确保只有单个线程更新变量的值。
- 该变量不会与其他变量一起纳入不变性条件中。
- 访问变量时不需要加锁。

**this逸出：**（1）在构造函数中启动一个线程会导致this溢出，只是创建没启动则无妨。（2）在构造函数中注册一个监听器也会导致this逸出。可以在私有构造函数中创建一个监听器，然后在共有静态方法中注册该监听器。（3）在构造函数中调用可改写的实例方法（非私有、非final）

**线程封闭：**

- ad-hoc线程封闭，代码自己实现封闭，如只有一个线程操作volatile变量的写入操作，则可确保volatile变量线程安全。但是封闭性较弱，容易被破坏
- 栈封闭。局部变量具有线程安全性，注意对象被逸出。
- ThreadLocal类，防止对可变的单实例对象或全局变量进行共享，例如连接数据库的Connection。

**不变性**

不可变对象一定是线程安全的。

当满足以下条件时，对象才是不可变的：

- 对象创建以后其状态就不能修改
- 对象的所有域都是final类型
- 对象是正确创建的（创建期间，this引用没有逸出）

对于访问多个相关变量出现竟态条件，可以将这些变量全部保存到一个不可变对象中来消除。

要安全的发布一个对象，对象的引用和对象的状态必须同时对其他线程可见。

**一个正确构造的对象可以通过以下方式安全的发布：**

- 在静态初始化函数中初始化一个对象引用
- 将对象的引用保存到volatile类型的域或者AtomicReference对象中
- 将对象的引用保存到某个正确构造对象的final类型域中
- 将对象的引用保存到一个由锁保护的域中

类的不变性条件和后验条件约束了哪些状态和状态转换是有效的。

**实例封闭：**当一个对象被封装在另一个对象中，能够访问被封装对象的所有路径都是已知的。

**Java监视器模式：**对象会把对象的所有可变状态都封装起来，并由对象的内置锁保护。

**现有安全类中添加功能：**

- 客户端加锁，比如通过同步容器的内置锁
- 组合，使用监视器模式

#### 第五章 基础构建模块

**同步容器类：**Vector、Hashtable、由Collections.synchronizedXxx()创建。

**问题：**在某些复合操作（迭代，若没有则添加）可能需要客户端加锁保护。

遍历同步容器的时候由其他线程修改了容器内容，可能会出现ArrayIndexOutOfBoundsException

```
for (int i = 0; i < vector.size(); i++) {
    doSomething(vector.get(i));
}
```

迭代容器时可能出现ConcurrentModificationException.

同步容器的实现方式是在访问状态时在方法上加锁，所以会导致系统吞吐量减小，所以推荐使用并发容器。

**并发容器：**ConcurrentHashMap、CopyOnWriteArrayList、Queue、BlockingQueue，并且增加了一些对复合操作的支持。

**ConcurrentHashMap：**其迭代器不会抛出ConcurrentModificationException，因此不需要在迭代时添加上锁。但是size和isEmpty语义可能被减弱了。其内部使用分段锁实现并发访问，可以并发修改和查看，但查看的结果可能并不是最新的。

由于ConcurrentHashMap不能用加锁的方式在进行独占式访问，所以不能通过客户端加锁的方式来进行某些原子的复合操作，但其内部实现了某些复合操作。

**CopyOnWriteArrayList：**用于替代同步的List，适用于遍历操作远多于修改操作，因为其底层维护了一个数组，每次修改都会创建一个底层数组。返回的元素与迭代器创建时的元素完全一致，不必考虑修改操作带来的影响。

当某方法抛出InterruptedException表示该方法是一个阻塞方法，如果这个方法中断，那么它将努力提前结束阻塞状态。

处理中断响应的方法：

- 传递InterruptedException，抛给它的调用者
- 恢复中断。在Runnable中必须捕获InterruptedException，并且通过当前线程的interrupt方法恢复中断状态。

**同步工具类：**可以是任何一个对象，只要它根据自身的状态协调线程的控制流。

- 阻塞队列
- 信号量（Semaphore）
- 栅栏（Barrier）
- 闭锁（Latch）

**闭锁：**可以延迟线程的进度直到其到达终止状态，当闭锁到达终止状态就不会再改变它的状态了。CountDownLatch是一种灵活的闭锁实现。闭锁的状态包括一个计数器，初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，await会一直阻塞等待计数器到零。

**FutureTask：**也可以作为闭锁
