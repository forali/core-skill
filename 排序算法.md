## 排序算法 ##

### 相关术语 ###
- 稳定性：如果a=b且a在b之前，经排序后a仍在b之前。
- 时间复杂度：对排序数据的总操作次数。反应排序元素个数n变化时，操作次数呈现什么变化。
- 空间复杂度：执行算法时所需的存储空间大小。

### 冒泡排序 ###
>重复遍历要排序的数列，依次比较相邻的两个元素，调整这两个元素的顺序，直到数列整体有序。

时间复杂度：O(n2)，空间复杂度：O(1)，稳定性：稳定

	public void bubble(int arr[]) {
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = i; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int swap = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = swap;
				}
			}
		}
	}

### 快速排序 ###
>通过一次排序将待排数列分为两个部分，其中一部分元素值比另一部分小，然后继续对这两部分执行上述操作，以达到整体有序。

时间复杂度：O(nlog2n)，空间复杂度：O(nlog2n)，稳定性：不稳定

	public class Quick {
	    public void quick(int[] arr, int left, int right) {
	        if (arr == null) {
	            return;
	        }
	        if (left < right) {
	            int index = partition(arr, left, right);
	            quick(arr, left, index - 1);
	            quick(arr, index + 1, right);
	        }
	    }
	
	    public int partition(int[] arr, int left, int right) {
	        // 选最左边的元素为基准pivot
	        int pivot = left, index = pivot + 1;
	        for (int i = index; i <= right; i++) {
	            if (arr[i] < arr[pivot]) {
	                swap(arr, i, index);
	                index++;
	            }
	        }
	        swap(arr, pivot, index - 1);
	        return index - 1;
	    }
	
	    public void swap(int[] arr, int i, int j) {
	        int temp = arr[i];
	        arr[i] = arr[j];
	        arr[j] = temp;
	    }
	
	    public static void main(String[] args) {
	        int[] arr = {1, 0, 2, 1, 3, 6, 2, 5, 4, 7};
	        new Quick().quick(arr, 0, arr.length - 1);
	        for (int item : arr) {
	            System.out.println(item);
	        }
	    }
	}

### 选择排序 ###
>在未排序的数列中找到最小（大）的数，放到已排序数列的最后，直到未排序数列为空。

时间复杂度：O(n2)，空间复杂度：O(1)，稳定性：不稳定

	public void select(int[] arr) {
		for (int i = 0; i < arr.length - 1; i++) {
			int index = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[index] > arr[j]) {
					int temp = arr[j];
					arr[j] = arr[i];
					arr[i] = temp;
				}
			}
		}
	}
