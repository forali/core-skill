## 排序算法 ##

### 相关术语 ###
- 稳定性：如果a=b且a在b之前，经排序后a仍在b之前。
- 时间复杂度：对排序数据的总操作次数。反应排序元素个数n变化时，操作次数呈现什么变化。
- 空间复杂度：执行算法时所需的存储空间大小。

### 冒泡排序（Bubble Sort） ###
>重复遍历要排序的数列，依次比较相邻的两个元素，调整这两个元素的顺序，直到数列整体有序。

时间复杂度：O(n<sup>2</sup>)，空间复杂度：O(1)，稳定性：稳定

	public void bubble(int arr[]) {
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = i; j < arr.length - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					int swap = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = swap;
				}
			}
		}
	}

### 快速排序（Quick Sort） ###
>通过一次排序将待排数列分为两个部分，其中一部分元素值比另一部分小，然后继续对这两部分执行上述操作，以达到整体有序。

时间复杂度：O(nlog<sub>2</sub>n)，空间复杂度：O(nlog<sub>2</sub>n)，稳定性：不稳定

	public class Quick {
	    public void quick(int[] arr, int left, int right) {
	        if (arr == null) {
	            return;
	        }
	        if (left < right) {
	            int index = partition(arr, left, right);
	            quick(arr, left, index - 1);
	            quick(arr, index + 1, right);
	        }
	    }
	
	    public int partition(int[] arr, int left, int right) {
	        // 选最左边的元素为基准pivot
	        int pivot = left, index = pivot + 1;
	        for (int i = index; i <= right; i++) {
	            if (arr[i] < arr[pivot]) {
	                swap(arr, i, index);
	                index++;
	            }
	        }
	        swap(arr, pivot, index - 1);
	        return index - 1;
	    }
	
	    public void swap(int[] arr, int i, int j) {
	        int temp = arr[i];
	        arr[i] = arr[j];
	        arr[j] = temp;
	    }
	
	    public static void main(String[] args) {
	        int[] arr = {1, 0, 2, 1, 3, 6, 2, 5, 4, 7};
	        new Quick().quick(arr, 0, arr.length - 1);
	        for (int item : arr) {
	            System.out.println(item);
	        }
	    }
	}

### 选择排序（Selection Sort） ###
>在未排序的数列中找到最小（大）的数，放到已排序数列的最后，直到未排序数列为空。

时间复杂度：O(n<sup>2</sup>)，空间复杂度：O(1)，稳定性：不稳定

	public void select(int[] arr) {
		for (int i = 0; i < arr.length - 1; i++) {
			int index = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[index] > arr[j]) {
					int temp = arr[j];
					arr[j] = arr[i];
					arr[i] = temp;
				}
			}
		}
	}

### 插入排序（Insertion Sort） ###
>构建有序数列，对于无序数列，从有序数列后面遍历，找到合适的位置插入。

时间复杂度：O(n<sup>2</sup>)，空间复杂度：O(1)，稳定性：稳定

	public void insert(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 1; i < arr.length; i++) {
            int preIndex = i - 1;
            int current = arr[i];
            while (preIndex >= 0 && arr[preIndex] > current) {
                arr[preIndex + 1] = arr[preIndex];
                preIndex--;
            }
            arr[preIndex + 1] = current;
        }
    }

### 希尔排序（Shell Sort） ###
>又称缩小增量排序，选取increment作为间隔分为increment个子序列，每个子序列使用直接插入排序，然后缩小increment直到increment=1。

时间复杂度：O(n<sup>1.3</sup>)，空间复杂度：O(1)，稳定性：不稳定

	public void shellSort(int[] arr) {
		if (arr == null || arr.length < 2) {
            return;
        }
        int increment = arr.length;
        do {
            increment = increment / 3 + 1;
            for (int i = increment; i < arr.length; i++) {
                int preIndex = i - increment;
                int current = arr[i];
                while (preIndex >= 0 && arr[preIndex] > current) {
                    arr[preIndex + increment] = arr[preIndex];
                    preIndex -= increment;
                }
                arr[preIndex + increment] = current;
            }
        } while (increment > 1);
    }


**increment的选取规则**

1. increment = n / 2向下取整，但是奇数位置和偶数位置在increment=1时才比较，效率低
2. increment = n / 3向下取整 + 1
